
# typescript TS 错误码大全

code|     类型|     英文描述  &  中文描述|
|:---:|:---:|:---:|
1002|     错误|     Unterminated string literal.    未终止的字符串文本。|
1003|     错误|     Identifier expected.    应为标识符。|
1005|     错误|     '{0}' expected.    应为“{0}”。|
1006|     错误|     A file cannot have a reference to itself.    文件不能引用自身。|
1009|     错误|     Trailing comma not allowed.    不允许使用尾随逗号。|
1010|     错误|     '*/' expected.     应为 "*/"。|
1012|     错误|     Unexpected token.    意外的标记。|
1014|     错误|     A rest parameter must be last in a parameter list.     rest 参数必须是参数列表中的最后一个参数。|
1015|     错误|     Parameter cannot have question mark and initializer.    参数不能包含问号和初始化表达式。|
1016|     错误|     A required parameter cannot follow an optional parameter.    必选参数不能位于可选参数后。|
1017|     错误|     An index signature cannot have a rest parameter.     索引签名不能包含 rest 参数。|
1018|     错误|     An index signature parameter cannot have an accessibility modifier.    索引签名参数不能具有可访问性修饰符。|
1019|     错误|     An index signature parameter cannot have a question mark.    索引签名参数不能包含问号。|
1020|     错误|     An index signature parameter cannot have an initializer.    索引签名参数不能具有初始化表达式。|
1021|     错误|     An index signature must have a type annotation.    索引签名必须具有类型批注。|
1022|     错误|     An index signature parameter must have a type annotation.    索引签名参数必须具有类型批注。|
1023|     错误|     An index signature parameter type must be 'string' or 'number'.    索引签名参数类型必须为 "string" 或 "number"。|
1024|     错误|     'readonly' modifier can only appear on a property declaration or index signature.|
1028|     错误|     Accessibility modifier already seen.    已看到可访问性修饰符。|
1029|     错误|     '{0}' modifier must precede '{1}' modifier.    “{0}”修饰符必须位于“{1}”修饰符之前。|
1030|     错误|     '{0}' modifier already seen.    已看到“{0}”修饰符。|
1031|     错误|     '{0}' modifier cannot appear on a class element.     “{0}”修饰符不能出现在类元素上。|
1034|     错误|     'super' must be followed by an argument list or member access.      "super" 后面必须是参数列表或成员访问。|
1035|     错误|     Only ambient modules can use quoted names.    仅环境模块可使用带引号的名称。|
1036|     错误|     Statements are not allowed in ambient contexts.    不允许在环境上下文中使用语句。|
1038|     错误|     A 'declare' modifier cannot be used in an already ambient context.    不能在已有的环境上下文中使用 "declare" 修饰符。|
1039|     错误|     Initializers are not allowed in ambient contexts.    不允许在环境上下文中使用初始化表达式。|
1040|     错误|     '{0}' modifier cannot be used in an ambient context.    “{0}”修饰符不能在环境上下文中使用。|
1041|     错误|     '{0}' modifier cannot be used with a class declaration.    “{0}”修饰符不能与类声明一起使用。|
1042|     错误|     '{0}' modifier cannot be used here.     “{0}”修饰符不能在此处使用。|
1043|     错误|     '{0}' modifier cannot appear on a data property.    “{0}”修饰符不能出现在数据属性上。|
1044|     错误|     '{0}' modifier cannot appear on a module or namespace element.    “{0}”修饰符不能出现在模块元素上。|
1045|     错误|     A '{0}' modifier cannot be used with an interface declaration.    “{0}”修饰符不能与接口声明一起使用。|
1046|     错误|     A 'declare' modifier is required for a top level declaration in a .d.ts file.    在 .d.ts 文件中的顶层声明需要 "declare" 修饰符。|
1047|     错误|     A rest parameter cannot be optional.    rest 参数不能为可选参数。|
1048|     错误|     A rest parameter cannot have an initializer.    rest 参数不能具有初始化表达式。|
1049|     错误|     A 'set' accessor must have exactly one parameter.    "set" 访问器必须正好具有一个参数。|
1051|     错误|     A 'set' accessor cannot have an optional parameter.    "set" 访问器不能具有可选参数。|
1052|     错误|     A 'set' accessor parameter cannot have an initializer.    "set" 访问器参数不能包含初始化表达式。|
1053|     错误|     A 'set' accessor cannot have rest parameter.     "set" 访问器不能具有 rest 参数。|
1054|     错误|     A 'get' accessor cannot have parameters.    "get" 访问器不能具有参数。|
1055|     错误|     Type '{0}' is not a valid async function return type in ES5/ES3 because it does not refer to a Promise-compatible constructor value.    类型“{0}”不是有效的异步函数返回类型。|
1056|     错误|     Accessors are only available when targeting ECMAScript 5 and higher.    访问器仅在面向 ECMAScript 5 和更高版本时可用。|
1057|     错误|     An async function or method must have a valid awaitable return type.    异步函数或方法必须具有有效的可等待返回类型。|
1058|     错误|     Operand for 'await' does not have a valid callable 'then' member.    "await" 的操作数不具有有效的可调用 "then" 成员。|
1059|     错误|     Return expression in async function does not have a valid callable 'then' member.    异步函数中的返回表达式不具有有效的可调用 "then" 成员。|
1060|     错误|     Expression body for async arrow function does not have a valid callable 'then' member.    异步箭头函数的表达式主体不具有有效的可调用 "then" 成员。|
1061|     错误|     Enum member must have initializer.    枚举成员必须具有初始化表达式。|
1062|     错误|     {0} is referenced directly or indirectly in the fulfillment callback of its own 'then' method.    {0} 在其自身的 "then" 方法的 fulfillment 回调中得到直接或间接引用。|
1063|     错误|     An export assignment cannot be used in a namespace.    不能在命名空间中使用导出分配。|
1064|     错误|     The return type of an async function or method must be the global Promise type.    The return type of an async function or method must be the global Promise type.|
1066|     错误|     In ambient enum declarations member initializer must be constant expression.    在环境枚举声明中，成员初始化表达式必须是常数表达式。|
1068|     错误|     Unexpected token. A constructor, method, accessor, or property was expected.    意外的标记。应为构造函数、方法、访问器或属性。|
1070|     错误|     '{0}' modifier cannot appear on a type member.|
1071|     错误|     '{0}' modifier cannot appear on an index signature.|
1079|     错误|     A '{0}' modifier cannot be used with an import declaration.     “{0}”修饰符不能与导入声明一起使用。|
1084|     错误|     Invalid 'reference' directive syntax.     "reference" 指令语法无效。|
1085|     错误|     Octal literals are not available when targeting ECMAScript 5 and higher. Use the syntax '{0}'.    面向 ECMAScript 5 和更高版本时，八进制文本不可用。|
1086|     错误|     An accessor cannot be declared in an ambient context.    不能在环境上下文中声明访问器。|
1089|     错误|     '{0}' modifier cannot appear on a constructor declaration.    “{0}”修饰符不能出现在构造函数声明中。|
1090|     错误|     '{0}' modifier cannot appear on a parameter.     “{0}”修饰符不能出现在参数中。|
1091|     错误|     Only a single variable declaration is allowed in a 'for...in' statement.    "for...in" 语句中只允许单个变量声明。|
1092|     错误|     Type parameters cannot appear on a constructor declaration.    类型参数不能出现在构造函数声明中。|
1093|     错误|     Type annotation cannot appear on a constructor declaration.    类型批注不能出现在构造函数声明中。|
1094|     错误|     An accessor cannot have type parameters.    访问器不能具有类型参数。|
1095|     错误|     A 'set' accessor cannot have a return type annotation.    "set" 访问器不能具有返回类型批注。|
1096|     错误|     An index signature must have exactly one parameter.    索引签名必须正好具有一个参数。|
1097|     错误|     '{0}' list cannot be empty.    “{0}”列表不能为空。|
1098|     错误|     Type parameter list cannot be empty.    类型参数列表不能为空。|
1099|     错误|     Type argument list cannot be empty.    类型参数列表不能为空。|
1100|     错误|     Invalid use of '{0}' in strict mode.    严格模式下“{0}”的使用无效。|
1101|     错误|     'with' statements are not allowed in strict mode.    严格模式下不允许使用 "with" 语句。|
1102|     错误|     'delete' cannot be called on an identifier in strict mode.    在严格模式下，无法对标识符调用 "delete"。|
1104|     错误|     A 'continue' statement can only be used within an enclosing iteration statement.    "continue" 语句只能在封闭迭代语句内使用。|
1105|     错误|     A 'break' statement can only be used within an enclosing iteration or switch statement.      "break" 语句只能在封闭迭代或 switch 语句内使用。|
1107|     错误|     Jump target cannot cross function boundary.    跳转目标不能跨越函数边界。|
1108|     错误|     A 'return' statement can only be used within a function body.    "return" 语句只能在函数体中使用。|
1109|     错误|     Expression expected.    应为表达式。|
1110|     错误|     Type expected.    应为类型。|
1113|     错误|     A 'default' clause cannot appear more than once in a 'switch' statement.    "default" 子句在"switch" 语句中只能出现一次。|
1114|     错误|     Duplicate label '{0}'    标签“{0}”重复|
1115|     错误|     A 'continue' statement can only jump to a label of an enclosing iteration statement.    "continue" 语句只能跳转到封闭迭代语句的标签。|
1116|     错误|     A 'break' statement can only jump to a label of an enclosing statement.    "break" 语句只能跳转到封闭语句的标签。|
1117|     错误|     An object literal cannot have multiple properties with the same name in strict mode.    严格模式下，对象文字不能包含多个具有相同名称的属性。|
1118|     错误|     An object literal cannot have multiple get/set accessors with the same name.    对象文字不能具有多个具有相同名称的 get/set 访问器。|
1119|     错误|     An object literal cannot have property and accessor with the same name.    对象文字不能包含具有相同名称的属性和访问器。|
1120|     错误|     An export assignment cannot have modifiers.    导出分配不能具有修饰符。|
1121|     错误|     Octal literals are not allowed in strict mode.    严格模式下不允许使用八进制文本。|
1122|     错误|     A tuple type element list cannot be empty.    元组类型元素列表不能为空。|
1123|     错误|     Variable declaration list cannot be empty.    变量声明列表不能为空。|
1124|     错误|     Digit expected.    应为数字。|
1125|     错误|     Hexadecimal digit expected.    应为十六进制数字。|
1126|     错误|     Unexpected end of text.    文本意外结束。|
1127|     错误|     Invalid character.    无效的字符。|
1128|     错误|     Declaration or statement expected.    应为声明或语句。|
1129|     错误|     Statement expected.    应为语句。|
1130|     错误|     'case' or 'default' expected.    应为 "case" 或 "default"。|
1131|     错误|     Property or signature expected.    应为属性或签名。|
1132|     错误|     Enum member expected.    应为枚举成员。|
1134|     错误|     Variable declaration expected.    应为变量声明。|
1135|     错误|     Argument expression expected.    应为参数表达式。|
1136|     错误|     Property assignment expected.    应为属性分配。|
1137|     错误|     Expression or comma expected.    应为表达式或逗号。|
1138|     错误|     Parameter declaration expected.    应为参数声明。|
1139|     错误|     Type parameter declaration expected.    应为类型参数声明。|
1140|     错误|     Type argument expected.    应为类型参数。|
1141|     错误|     String literal expected.    应为字符串文本。|
1142|     错误|     Line break not permitted here.    不允许在此处换行。|
1144|     错误|     '{' or ';' expected.    应为 "{" 或 ";"。|
1146|     错误|     Declaration expected.    应为声明。|
1147|     错误|     Import declarations in a namespace cannot reference a module.    命名空间中的导入声明不能引用模块。|
1148|     错误|     Cannot use imports, exports, or module augmentations when '--module' is 'none'.    Cannot compile modules unless the '--module' flag is provided with a valid module type. Consider setting the 'module' compiler option in a 'tsconfig.json' file.|
1149|     错误|     File name '{0}' differs from already included file name '{1}' only in casing    文件名“{0}”仅在大小写方面与包含的文件名“{1}”不同|
1150|     错误|     'new T[]' cannot be used to create an array. Use 'new Array ()' instead.    "new T[]" 不能用于创建数组。请改用 "new Array ()"。|
1155|     错误|     'const' declarations must be initialized    必须初始化 "const" 声明|
1156|     错误|     'const' declarations can only be declared inside a block.    "const" 声明只能在块的内部声明。|
1157|     错误|     'let' declarations can only be declared inside a block.    "let" 声明只能在块的内部声明。|
1160|     错误|     Unterminated template literal.    未终止的模板文本。|
1161|     错误|     Unterminated regular expression literal.    未终止的正则表达式文本。|
1162|     错误|     An object member cannot be declared optional.    对象成员无法声明为可选。|
1163|     错误|     A 'yield' expression is only allowed in a generator body.    只允许在生成器正文中使用 "yield" 表达式。|
1164|     错误|     Computed property names are not allowed in enums.    枚举中不允许计算属性名。|
1165|     错误|     A computed property name in an ambient context must directly refer to a built-in symbol.    环境上下文中的计算属性名必须直接引用内置符号。|
1166|     错误|     A computed property name in a class property declaration must directly refer to a built-in symbol.    类属性声明中的计算属性名必须直接引用内置符号。|
1168|     错误|     A computed property name in a method overload must directly refer to a built-in symbol.    方法重载中的计算属性名必须直接引用内置符号。|
1169|     错误|     A computed property name in an interface must directly refer to a built-in symbol.    接口中的计算属性名必须直接引用内置符号。|
1170|     错误|     A computed property name in a type literal must directly refer to a built-in symbol.    类型文本中的计算属性名必须直接引用内置符号。|
1171|     错误|     A comma expression is not allowed in a computed property name.    计算属性名中不允许逗号表达式。|
1172|     错误|     'extends' clause already seen.    已看到 "extends" 子句。|
1173|     错误|     'extends' clause must precede 'implements' clause.    "extends" 子句必须位于 "implements" 子句之前。|
1174|     错误|     Classes can only extend a single class.    类只能扩展一个类。|
1175|     错误|     'implements' clause already seen.    已看到 "implements" 子句。|
1176|     错误|     Interface declaration cannot have 'implements' clause.    接口声明不能有 "implements" 子句。|
1177|     错误|     Binary digit expected.    需要二进制数字。|
1178|     错误|     Octal digit expected.    需要八进制数字。|
1179|     错误|     Unexpected token. '{' expected.    意外标记。应为 "{"。|
1180|     错误|     Property destructuring pattern expected.    应为属性析构模式。|
1181|     错误|     Array element destructuring pattern expected.    应为数组元素析构模式。|
1182|     错误|     A destructuring declaration must have an initializer.    析构声明必须具有初始化表达式。|
1183|     错误|     An implementation cannot be declared in ambient contexts.    不能在环境上下文中声明实现。|
1184|     错误|     Modifiers cannot appear here.    修饰符不能出现在此处。|
1185|     错误|     Merge conflict marker encountered.    遇到合并冲突标记。|
1186|     错误|     A rest element cannot have an initializer.    rest 元素不能具有初始化表达式。|
1187|     错误|     A parameter property may not be declared using a binding pattern.    参数属性不能为绑定模式。|
1188|     错误|     Only a single variable declaration is allowed in a 'for...of' statement.     "for...of" 语句中只允许单个变量声明。|
1189|     错误|     The variable declaration of a 'for...in' statement cannot have an initializer.    "for...in" 语句的变量声明不能有初始化表达式。|
1190|     错误|     The variable declaration of a 'for...of' statement cannot have an initializer.    "for...of" 语句的变量声明不能有初始化表达式。|
1191|     错误|     An import declaration cannot have modifiers.    导入声明不能有修饰符。|
1192|     错误|     Module '{0}' has no default export.    模块“{0}”没有默认导出。|
1193|     错误|     An export declaration cannot have modifiers.    导出声明不能有修饰符。|
1194|     错误|     Export declarations are not permitted in a namespace.    命名空间中不允许有导出声明。|
1196|     错误|     Catch clause variable cannot have a type annotation.    Catch 子句变量不能有类型批注。|
1197|     错误|     Catch clause variable cannot have an initializer.    Catch 子句变量不能有初始化表达式。|
1198|     错误|     An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.    扩展的 Unicode 转义值必须介于(含) 0x0 和 0x10FFFF 之间。|
1199|     错误|     Unterminated Unicode escape sequence.    未终止的 Unicode 转义序列。|
1200|     错误|     Line terminator not permitted before arrow.    箭头前不允许有行终止符。|
1202|     错误|     Import assignment cannot be used when targeting ECMAScript 2015 modules. Consider using 'import *as ns from "mod"', 'import {a} from "mod"', 'import d from "mod"', or another module format instead.    当面向 ECMAScript 6 模块时，不能使用导入分配。请考虑改用 "import* as ns from "mod"" 、"import {a} from "mod"" 或 "import d from "mod"" 或其他模块格式。|
1203|     错误|     Export assignment cannot be used when targeting ECMAScript 2015 modules. Consider using 'export default' or another module format instead.    当面向 ECMAScript 6 模块时，不能使用导出分配。请考虑改用“导出默认”或其他模块格式。|
1206|     错误|     Decorators are not valid here.    修饰器在此处无效。|
1207|     错误|     Decorators cannot be applied to multiple get/set accessors of the same name.    不能向多个同名的 get/set 访问器应用修饰器。|
1208|     错误|     Cannot compile namespaces when the '--isolatedModules' flag is provided.    提供 "--isolatedModules" 标志时无法编译命名空间。|
1209|     错误|     Ambient const enums are not allowed when the '--isolatedModules' flag is provided.    提供 "--isolatedModules" 标志的情况下不允许使用环境常数枚举。|
1210|     错误|     Invalid use of '{0}'. Class definitions are automatically in strict mode.    “{0}”的使用无效。类定义自动处于严格模式。|
1211|     错误|     A class declaration without the 'default' modifier must have a name    不带 "default" 修饰符的类声明必须具有名称|
1212|     错误|     Identifier expected. '{0}' is a reserved word in strict mode     应为标识符。“{0}”在严格模式下是保留字|
1213|     错误|     Identifier expected. '{0}' is a reserved word in strict mode. Class definitions are automatically in strict mode.    应为标识符。“{0}”在严格模式下是保留字。类定义自动处于严格模式。|
1214|     错误|     Identifier expected. '{0}' is a reserved word in strict mode. Modules are automatically in strict mode.    应为标识符。“{0}”是严格模式下的保留字。模块自动处于严格模式。|
1215|     错误|     Invalid use of '{0}'. Modules are automatically in strict mode.    “{0}”的使用无效。模块自动处于严格模式。|
1218|     错误|     Export assignment is not supported when '--module' flag is 'system'.    当 "--module" 标志是 "system" 时不支持导出分配。|
1219|     错误|     Experimental support for decorators is a feature that is subject to change in a future release. Set the 'experimentalDecorators' option to remove this warning.    Experimental support for decorators is a feature that is subject to change in a future release. Set the 'experimentalDecorators' option to remove this warning.|
1220|     错误|     Generators are only available when targeting ECMAScript 2015 or higher.    仅当面向 ECMAScript 6 或更高版本时，生成器才可用。|
1221|     错误|     Generators are not allowed in an ambient context.    不允许在环境上下文中使用生成器。|
1222|     错误|     An overload signature cannot be declared as a generator.    重载签名无法声明为生成器。|
1223|     错误|     '{0}' tag already specified.    已指定“{0}”标记。|
1224|     错误|     Signature '{0}' must have a type predicate.    签名“{0}”必须具有类型谓词。|
1225|     错误|     Cannot find parameter '{0}'.    找不到参数“{0}”。|
1226|     错误|     Type predicate '{0}' is not assignable to '{1}'.    类型谓词“{0}”不可分配给“{1}”。|
1227|     错误|     Parameter '{0}' is not in the same position as parameter '{1}'.    参数“{0}”和参数“{1}”的位置不一样。|
1228|     错误|     A type predicate is only allowed in return type position for functions and methods.    只允许在函数和方法的返回类型位置使用类型谓词。|
1229|     错误|     A type predicate cannot reference a rest parameter.    类型谓词无法引用 rest 参数|
1230|     错误|     A type predicate cannot reference element '{0}' in a binding pattern.    类型谓词无法在绑定模式中引用元素“{0}”。|
1231|     错误|     An export assignment can only be used in a module.    导出分配只能在模块中使用。|
1232|     错误|     An import declaration can only be used in a namespace or module.    导入声明只能在命名空间或模块中使用。|
1233|     错误|     An export declaration can only be used in a module.    导出声明只能在模块中使用。|
1234|     错误|     An ambient module declaration is only allowed at the top level in a file.    只允许在文件的顶层中使用环境模块声明。|
1235|     错误|     A namespace declaration is only allowed in a namespace or module.    只允许在命名空间或模块中使用命名空间声明。|
1236|     错误|     The return type of a property decorator function must be either 'void' or 'any'.    属性修饰器函数的返回类型必须为 "void" 或 "any"。|
1237|     错误|     The return type of a parameter decorator function must be either 'void' or 'any'.    参数修饰器函数的返回类型必须为 "void" 或 "any"。|
1238|     错误|     Unable to resolve signature of class decorator when called as an expression.    作为表达式调用时，无法解析类修饰器的签名。|
1239|     错误|     Unable to resolve signature of parameter decorator when called as an expression.    作为表达式调用时，无法解析参数修饰器的签名。|
1240|     错误|     Unable to resolve signature of property decorator when called as an expression.    作为表达式调用时，无法解析属性修饰器的签名。|
1241|     错误|     Unable to resolve signature of method decorator when called as an expression.    作为表达式调用时，无法解析方法修饰器的签名。|
1242|     错误|     'abstract' modifier can only appear on a class, method, or property declaration.    "abstract" 修饰符只能出现在类声明或方法声明中。|
1243|     错误|     '{0}' modifier cannot be used with '{1}' modifier.    “{0}”修饰符不能与“{1}”修饰符一起使用。|
1244|     错误|     Abstract methods can only appear within an abstract class.    抽象方法只能出现在抽象类中。|
1245|     错误|     Method '{0}' cannot have an implementation because it is marked abstract.    方法“{0}”不能具有实现，因为它标记为抽象。|
1246|     错误|     An interface property cannot have an initializer.    接口函数不能具有初始化表达式。|
1247|     错误|     A type literal property cannot have an initializer.    类型文字数据不可具有初始化表达式。|
1248|     错误|     A class member cannot have the '{0}' keyword.    A class member cannot have the '{0}' keyword.|
1249|     错误|     A decorator can only decorate a method implementation, not an overload.    A decorator can only decorate a method implementation, not an overload.|
1250|     错误|     Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'.|
1251|     错误|     Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'. Class definitions are automatically in strict mode.|
1252|     错误|     Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'. Modules are automatically in strict mode.|
1253|     错误|     '{0}' tag cannot be used independently as a top level JSDoc tag.|
1254|     错误|     A 'const' initializer in an ambient context must be a string or numeric literal.|
1300|     错误|     'with' statements are not allowed in an async function block.     不允许在异步函数块中使用 "with" 语句。|
1308|     错误|     'await' expression is only allowed within an async function.    只允许在异步函数中使用 "await" 表达式。|
1312|     错误|     '=' can only be used in an object literal property inside a destructuring assignment.    "=" 只可在重构赋值内部的对象文字属性中使用。|
1313|     错误|     The body of an 'if' statement cannot be the empty statement.    "if" 语句的正文不能为空语句。|
1314|     错误|     Global module exports may only appear in module files.|
1315|     错误|     Global module exports may only appear in declaration files.|
1316|     错误|     Global module exports may only appear at top level.|
1317|     错误|     A parameter property cannot be declared using a rest parameter.|
1318|     错误|     An abstract accessor cannot have an implementation.|
1319|     错误|     A default export can only be used in an ECMAScript-style module.|
2300|     错误|     Duplicate identifier '{0}'.    标识符“{0}”重复。|
2301|     错误|     Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.    实例成员变量“{0}”的初始化表达式不能引用构造函数中声明的标识符“{1}”。|
2302|     错误|     Static members cannot reference class type parameters.    静态成员不能引用类类型参数。|
2303|     错误|     Circular definition of import alias '{0}'.    导入别名“{0}”的循环定义。|
2304|     错误|     Cannot find name '{0}'.    找不到名称“{0}”。|
2305|     错误|     Module '{0}' has no exported member '{1}'.    模块“{0}”没有导出的成员“{1}”。|
2306|     错误|     File '{0}' is not a module.    文件“{0}”不是模块。|
2307|     错误|     Cannot find module '{0}'.    找不到模块“{0}”。|
2308|     错误|     Module {0} has already exported a member named '{1}'. Consider explicitly re-exporting to resolve the ambiguity.    模块 {0} 已导出一个名为“{1}”的成员。请考虑重新显式导出以解决歧义。|
2309|     错误|     An export assignment cannot be used in a module with other exported elements.    不能在具有其他导出元素的模块中使用导出分配。|
2310|     错误|     Type '{0}' recursively references itself as a base type.    类型“{0}”以递归方式将自身引用为基类。|
2311|     错误|     A class may only extend another class.    类只能扩展其他类。|
2312|     错误|     An interface may only extend a class or another interface.    接口只能扩展类或其他接口。|
2313|     错误|     Type parameter '{0}' has a circular constraint.    Type parameter '{0}' has a circular constraint.|
2314|     错误|     Generic type '{0}' requires {1} type argument(s).    泛型类型“{0}”需要 {1} 个类型参数。|
2315|     错误|     Type '{0}' is not generic.    类型“{0}”不是泛型类型。|
2316|     错误|     Global type '{0}' must be a class or interface type.    全局类型“{0}”必须为类或接口类型。|
2317|     错误|     Global type '{0}' must have {1} type parameter(s).    全局类型“{0}”必须具有 {1} 个类型参数。|
2318|     错误|     Cannot find global type '{0}'.    找不到全局类型“{0}”。|
2319|     错误|     Named property '{0}' of types '{1}' and '{2}' are not identical.    “{1}”和“{2}”类型的命名属性“{0}”不完全相同。|
2320|     错误|     Interface '{0}' cannot simultaneously extend types '{1}' and '{2}'.    接口“{0}”不能同时扩展类型“{1}”和“{2}”。|
2321|     错误|     Excessive stack depth comparing types '{0}' and '{1}'.    与类型“{0}”和“{1}”相比，堆栈深度过高。|
2322|     错误|     Type '{0}' is not assignable to type '{1}'.    不能将类型“{0}”分配给类型“{1}”。|
2323|     错误|     Cannot redeclare exported variable '{0}'.    无法重新声明导出的变量“{0}”。|
2324|     错误|     Property '{0}' is missing in type '{1}'.    类型“{1}”中缺少属性“{0}”。|
2325|     错误|     Property '{0}' is private in type '{1}' but not in type '{2}'.    属性“{0}”在类型“{1}”中是私有属性，但在类型“{2}”中不是。|
2326|     错误|     Types of property '{0}' are incompatible.    属性“{0}”的类型不兼容。|
2327|     错误|     Property '{0}' is optional in type '{1}' but required in type '{2}'.    属性“{0}”在类型“{1}”中为可选，但在类型“{2}”中为必选。|
2328|     错误|     Types of parameters '{0}' and '{1}' are incompatible.    参数“{0}”和“{1}” 的类型不兼容。|
2329|     错误|     Index signature is missing in type '{0}'.    类型“{0}”中缺少索引签名。|
2330|     错误|     Index signatures are incompatible.    索引签名不兼容。|
2331|     错误|     'this' cannot be referenced in a module or namespace body.    不能在模块或命名空间体中引用 "this"。|
2332|     错误|     'this' cannot be referenced in current location.    不能在当前位置引用 "this"。|
2333|     错误|     'this' cannot be referenced in constructor arguments.    不能在构造函数参数中引用 "this"。|
2334|     错误|     'this' cannot be referenced in a static property initializer.    不能在静态属性初始化表达式中引用 "this"。|
2335|     错误|     'super' can only be referenced in a derived class.    只能在派生类中引用 "super"。|
2336|     错误|     'super' cannot be referenced in constructor arguments.    不能在构造函数参数中引用 "super"。|
2337|     错误|     Super calls are not permitted outside constructors or in nested functions inside constructors.    不允许在构造函数外部或在构造函数内的嵌套函数中进行 Super 调用。|
2338|     错误|     'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.    只有构造函数、成员函数或派生类的成员访问器中才允许 "super" 属性访问。|
2339|     错误|     Property '{0}' does not exist on type '{1}'.    类型“{1}”上不存在属性“{0}”。|
2340|     错误|     Only public and protected methods of the base class are accessible via the 'super' keyword.    通过 "super" 关键字只能访问基类的公共方法和受保护方法。|
2341|     错误|     Property '{0}' is private and only accessible within class '{1}'.    属性“{0}”为私有属性，只能在类“{1}”中访问。|
2342|     错误|     An index expression argument must be of type 'string', 'number', 'symbol', or 'any'.    索引表达式参数必须为 "string"、"number"、"symbol" 或 "any" 类型。|
2343|     错误|     This syntax requires an imported helper named '{1}', but module '{0}' has no exported member '{1}'.|
2344|     错误|     Type '{0}' does not satisfy the constraint '{1}'.    类型“{0}”不满足约束“{1}”。|
2345|     错误|     Argument of type '{0}' is not assignable to parameter of type '{1}'.    类型“{0}”的参数不能赋给类型“{1}”的参数。|
2346|     错误|     Supplied parameters do not match any signature of call target.    提供的参数与调用目标的任何签名都不匹配。|
2347|     错误|     Untyped function calls may not accept type arguments.    非类型化函数调用不能接受类型参数。|
2348|     错误|     Value of type '{0}' is not callable. Did you mean to include 'new'?    类型“{0}”的值不可调用。是否希望包括 "new"?|
2349|     错误|     Cannot invoke an expression whose type lacks a call signature. Type '{0}' has no compatible call signatures.    无法调用其类型缺少调用签名的表达式。|
2350|     错误|     Only a void function can be called with the 'new' keyword.    使用 "new" 关键字只能调用 void 函数。|
2351|     错误|     Cannot use 'new' with an expression whose type lacks a call or construct signature.    其类型缺少调用或构造签名的表达式无法使用 "new"。|
2352|     错误|     Type '{0}' cannot be converted to type '{1}'.    类型“{0}”和类型“{1}”均不能赋给对方。|
2353|     错误|     Object literal may only specify known properties, and '{0}' does not exist in type '{1}'.    对象文字可以只指定已知属性，并且“{0}”不在类型“{1}”中。|
2354|     错误|     This syntax requires an imported helper but module '{0}' cannot be found.    返回表达式中不存在最佳通用类型。|
2355|     错误|     A function whose declared type is neither 'void' nor 'any' must return a value.    其声明类型不为 "void" 或 "any" 的函数必须返回值。|
2356|     错误|     An arithmetic operand must be of type 'any', 'number' or an enum type.    算术操作数必须为类型 "any"、"number" 或枚举类型。|
2357|     错误|     The operand of an increment or decrement operator must be a variable or a property access.    增量或减量运算符的操作数必须为变量、属性或索引器。|
2358|     错误|     The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.    "instanceof" 表达式左侧必须是 "any" 类型、对象类型或类型参数。|
2359|     错误|     The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.    "instanceof" 表达式的右侧必须属于类型 "any"，或属于可分配给 "Function" 接口类型的类型。|
2360|     错误|     The left-hand side of an 'in' expression must be of type 'any', 'string', 'number', or 'symbol'.    "in" 表达式左侧的类型必须为 "any"、"string"、"number" 或 "symbol"。|
2361|     错误|     The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter    "in" 表达式的右侧必须是 "any" 类型、对象类型或类型参数|
2362|     错误|     The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.    算术运算左侧必须是 "any"、"number" 或枚举类型。|
2363|     错误|     The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.    算术运算右侧必须是 "any"、"number" 或枚举类型。|
2364|     错误|     The left-hand side of an assignment expression must be a variable or a property access.    赋值表达式左侧无效。|
2365|     错误|     Operator '{0}' cannot be applied to types '{1}' and '{2}'.    运算符“{0}”不能应用于类型“{1}”和“{2}”。|
2366|     错误|     Function lacks ending return statement and return type does not include 'undefined'.|
2368|     错误|     Type parameter name cannot be '{0}'    类型参数名称不能为“{0}”|
2369|     错误|     A parameter property is only allowed in a constructor implementation.    只允许在构造函数实现中使用参数属性。|
2370|     错误|     A rest parameter must be of an array type.    rest 参数必须是数组类型。|
2371|     错误|     A parameter initializer is only allowed in a function or constructor implementation.    只允许在函数或构造函数实现中使用参数初始化表达式。|
2372|     错误|     Parameter '{0}' cannot be referenced in its initializer.    参数“{0}”的初始化表达式中不能引用该参数自身。|
2373|     错误|     Initializer of parameter '{0}' cannot reference identifier '{1}' declared after it.    参数“{0}”的初始化表达式不能引用在它之后声明的标识符“{1}”。|
2374|     错误|     Duplicate string index signature.    字符串索引签名重复。|
2375|     错误|     Duplicate number index signature.    数字索引签名重复。|
2376|     错误|     A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.    当类包含初始化的属性或参数属性时，"super" 调用必须是构造函数中的第一个语句。|
2377|     错误|     Constructors for derived classes must contain a 'super' call.    派生类的构造函数必须包含 "super" 调用。|
2378|     错误|     A 'get' accessor must return a value.    "get" 访问器必须返回值。|
2379|     错误|     Getter and setter accessors do not agree in visibility.    Getter 和 setter 访问器在可见性上不一致。|
2380|     错误|     'get' and 'set' accessor must have the same type.    "get" 和 "set" 访问器必须属于同一类型。|
2381|     错误|     A signature with an implementation cannot use a string literal type.    具有实现的签名不能使用字符串文本类型。|
2382|     错误|     Specialized overload signature is not assignable to any non-specialized signature.    指定的重载签名不可分配给任何非专用化签名。|
2383|     错误|     Overload signatures must all be exported or non-exported.    重载签名必须全部导出或全部不导出。|
2384|     错误|     Overload signatures must all be ambient or non-ambient.    重载签名必须全部为环境签名或非环境签名。|
2385|     错误|     Overload signatures must all be public, private or protected.    重载签名必须全部是公共签名、私有签名或受保护签名。|
2386|     错误|     Overload signatures must all be optional or required.    重载签名必须全部为可选签名或必需签名。|
2387|     错误|     Function overload must be static.    函数重载必须为静态。|
2388|     错误|     Function overload must not be static.    函数重载不能为静态。|
2389|     错误|     Function implementation name must be '{0}'.    函数实现名称必须为“{0}”。|
2390|     错误|     Constructor implementation is missing.    缺少构造函数实现。|
2391|     错误|     Function implementation is missing or not immediately following the declaration.    函数实现缺失或未立即出现在声明之后。|
2392|     错误|     Multiple constructor implementations are not allowed.    不允许存在多个构造函数实现。|
2393|     错误|     Duplicate function implementation.    函数实现重复。|
2394|     错误|     Overload signature is not compatible with function implementation.    重载签名与函数实现不兼容。|
2395|     错误|     Individual declarations in merged declaration '{0}' must be all exported or all local.    合并声明“{0}”中的单独声明必须全为导出或全为局部声明。|
2396|     错误|     Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.    标识符 "arguments" 重复。编译器使用 "arguments" 初始化 rest 参数。|
2397|     错误|     Declaration name conflicts with built-in global identifier '{0}'.    Declaration name conflicts with built-in global identifier '{0}'.|
2399|     错误|     Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.    标识符 "_this" 重复。编译器使用变量声明 "_this" 来捕获 "this" 引用。|
2400|     错误|     Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.    表达式解析为编译器用于捕获 "this" 引用的变量声明 "_this"。|
2401|     错误|     Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.    标识符 "_super" 重复。编译器使用 "_super" 获取基类引用。|
2402|     错误|     Expression resolves to '_super' that compiler uses to capture base class reference.    表达式解析为 "_super"，编译器使用 "_super" 获取基类引用。|
2403|     错误|     Subsequent variable declarations must have the same type. Variable '{0}' must be of type '{1}', but here has type '{2}'.    后续变量声明必须属于同一类型。变量“{0}”必须属于类型“{1}”，但此处却为类型“{2}”。|
2404|     错误|     The left-hand side of a 'for...in' statement cannot use a type annotation.    "for...in" 语句的左侧不能使用类型批注。|
2405|     错误|     The left-hand side of a 'for...in' statement must be of type 'string' or 'any'.    "for...in" 语句的左侧必须是 "string" 或 "any" 类型。|
2406|     错误|     The left-hand side of a 'for...in' statement must be a variable or a property access.    "for...in" 语句左侧无效。|
2407|     错误|     The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.    "for...in" 语句右侧必须是 "any" 类型、对象类型或类型参数。|
2408|     错误|     Setters cannot return a value.    Setter 不能返回值。|
2409|     错误|     Return type of constructor signature must be assignable to the instance type of the class    构造函数签名的返回类型必须可赋给类的实例类型|
2410|     错误|     The 'with' statement is not supported. All symbols in a 'with' block will have type 'any'.    "with" 块内的所有符号都将被解析为 "any"。|
2411|     错误|     Property '{0}' of type '{1}' is not assignable to string index type '{2}'.    类型“{1}”的属性“{0}”不能赋给字符串索引类型“{2}”。|
2412|     错误|     Property '{0}' of type '{1}' is not assignable to numeric index type '{2}'.    类型“{1}”的属性“{0}”不能赋给数值索引类型“{2}”。|
2413|     错误|     Numeric index type '{0}' is not assignable to string index type '{1}'.    数字索引类型“{0}”不能赋给字符串索引类型“{1}”。|
2414|     错误|     Class name cannot be '{0}'    类名不能为“{0}”|
2415|     错误|     Class '{0}' incorrectly extends base class '{1}'.    类“{0}”错误扩展基类“{1}”。|
2417|     错误|     Class static side '{0}' incorrectly extends base class static side '{1}'.    类静态侧“{0}”错误扩展基类静态侧“{1}”。|
2420|     错误|     Class '{0}' incorrectly implements interface '{1}'.    类“{0}”错误实现接口“{1}”。|
2422|     错误|     A class may only implement another class or interface.    类只能实现其他类或接口。|
2423|     错误|     Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.    类“{0}”将“{1}”定义为实例成员函数，但扩展类“{2}”将其定义为实例成员访问器。|
2424|     错误|     Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.    类“{0}”将“{1}”定义为实例成员函数，但扩展类“{2}”将其定义为实例成员属性。|
2425|     错误|     Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.    类“{0}”将“{1}”定义为实例成员属性，但扩展类“{2}”将其定义为实例成员函数。|
2426|     错误|     Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.    类“{0}”将“{1}”定义为实例成员访问器，但扩展类“{2}”将其定义为实例成员函数。|
2427|     错误|     Interface name cannot be '{0}'    接口名不能为“{0}”|
2428|     错误|     All declarations of '{0}' must have identical type parameters.    接口的所有声明必须具有相同的类型参数。|
2430|     错误|     Interface '{0}' incorrectly extends interface '{1}'.    接口“{0}”错误扩展接口“{1}”。|
2431|     错误|     Enum name cannot be '{0}'    枚举名不能为“{0}”|
2432|     错误|     In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element.    在包含多个声明的枚举中，只有一个声明可以省略其第一个枚举元素的初始化表达式。|
2433|     错误|     A namespace declaration cannot be in a different file from a class or function with which it is merged    命名空间声明不能位于与之合并的类或函数中的其他文件内|
2434|     错误|     A namespace declaration cannot be located prior to a class or function with which it is merged    命名空间声明不能位于与之合并的类或函数前|
2435|     错误|     Ambient modules cannot be nested in other modules or namespaces.    环境模块不能嵌套在其他模块或命名空间中。|
2436|     错误|     Ambient module declaration cannot specify relative module name.    环境模块声明无法指定相对模块名。|
2437|     错误|     Module '{0}' is hidden by a local declaration with the same name    模块“{0}”被具有相同名称的局部声明隐藏|
2438|     错误|     Import name cannot be '{0}'    导入名称不能为“{0}”|
2439|     错误|     Import or export declaration in an ambient module declaration cannot reference module through relative module name.    环境模块声明中的导入或导出声明不能通过相对模块名引用模块。|
2440|     错误|     Import declaration conflicts with local declaration of '{0}'    导入声明与“{0}”的局部声明冲突|
2441|     错误|     Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module.    标识符“{0}”重复。编译器在模块的顶层范围中保留名称“{1}”。|
2442|     错误|     Types have separate declarations of a private property '{0}'.    类型具有私有属性“{0}”的单独声明。|
2443|     错误|     Property '{0}' is protected but type '{1}' is not a class derived from '{2}'.    属性“{0}”受保护，但类型“{1}”并不是从“{2}”派生的类。|
2444|     错误|     Property '{0}' is protected in type '{1}' but public in type '{2}'.    属性“{0}”在类型“{1}”中受保护，但在类型“{2}”中为公共属性。|
2445|     错误|     Property '{0}' is protected and only accessible within class '{1}' and its subclasses.    属性“{0}”受保护，只能在类“{1}”及其子类中访问。|
2446|     错误|     Property '{0}' is protected and only accessible through an instance of class '{1}'.    属性“{0}”受保护，只能通过类“{1}”的实例访问。|
2447|     错误|     The '{0}' operator is not allowed for boolean types. Consider using '{1}' instead.    “{0}”运算符不允许用于布尔类型。请考虑改用“{1}”。|
2448|     错误|     Block-scoped variable '{0}' used before its declaration.    声明之前已使用的块范围变量“{0}”。|
2451|     错误|     Cannot redeclare block-scoped variable '{0}'.    无法重新声明块范围变量“{0}”。|
2452|     错误|     An enum member cannot have a numeric name.    枚举成员不能具有数值名。|
2453|     错误|     The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.    无法从用法推断类型形参“{0}”的类型实参。可以考虑显式指定类型实参。|
2454|     错误|     Variable '{0}' is used before being assigned.|
2455|     错误|     Type argument candidate '{1}' is not a valid type argument because it is not a supertype of candidate '{0}'.    候选类型参数“{1}”不是有效的类型参数，因为它不是候选“{0}”的超类型。|
2456|     错误|     Type alias '{0}' circularly references itself.    类型别名“{0}”循环引用自身。|
2457|     错误|     Type alias name cannot be '{0}'    类型别名不能为“{0}”|
2458|     错误|     An AMD module cannot have multiple name assignments.    AMD 模块无法拥有多个名称分配。|
2459|     错误|     Type '{0}' has no property '{1}' and no string index signature.    类型“{0}”不具有属性“{1}”和字符串索引签名。|
2460|     错误|     Type '{0}' has no property '{1}'.    类型“{0}”不具有属性“{1}”。|
2461|     错误|     Type '{0}' is not an array type.    类型“{0}”不是数组类型。|
2462|     错误|     A rest element must be last in a destructuring pattern    rest 元素必须在数组析构模式中位于最末|
2463|     错误|     A binding pattern parameter cannot be optional in an implementation signature.    绑定模式参数在实现签名中不能为可选参数。|
2464|     错误|     A computed property name must be of type 'string', 'number', 'symbol', or 'any'.    计算属性名的类型必须为 "string"、"number"、"symbol" 或 "any"。|
2465|     错误|     'this' cannot be referenced in a computed property name.    不能在计算属性名中引用 "this"。|
2466|     错误|     'super' cannot be referenced in a computed property name.    不能在计算属性名中引用 "super"。|
2467|     错误|     A computed property name cannot reference a type parameter from its containing type.    计算属性名无法从其包含的类型引用类型参数。|
2468|     错误|     Cannot find global value '{0}'.    找不到全局值“{0}”。|
2469|     错误|     The '{0}' operator cannot be applied to type 'symbol'.    “{0}”运算符不能应用于类型 "symbol"。|
2470|     错误|     'Symbol' reference does not refer to the global Symbol constructor object.    "Symbol" 引用不是指全局符号构造函数对象。|
2471|     错误|     A computed property name of the form '{0}' must be of type 'symbol'.    窗体“{0}”的计算属性名必须是 "symbol" 类型。|
2472|     错误|     Spread operator in 'new' expressions is only available when targeting ECMAScript 5 and higher.    仅当面向 ECMAScript 5 和更高版本时，"new" 表达式中的展开运算符才可用。|
2473|     错误|     Enum declarations must all be const or non-const.    枚举声明必须全为常数或非常数。|
2474|     错误|     In 'const' enum declarations member initializer must be constant expression.    在 "const" 枚举声明中，成员初始化表达式必须是常数表达式。|
2475|     错误|     'const' enums can only be used in property or index access expressions or the right hand side of an import declaration or export assignment.    "const" 枚举仅可在属性、索引访问表达式、导入声明的右侧或导出分配中使用。|
2476|     错误|     A const enum member can only be accessed using a string literal.    只有使用字符串文本才能访问常数枚举成员。|
2477|     错误|     'const' enum member initializer was evaluated to a non-finite value.    "const" 枚举成员初始化表达式的求值结果为非有限值。|
2478|     错误|     'const' enum member initializer was evaluated to disallowed value 'NaN'.    "const" 枚举成员初始化表达式的求值结果为不允许使用的值 "NaN"。|
2479|     错误|     Property '{0}' does not exist on 'const' enum '{1}'.    "const" 枚举“{1}”上不存在属性“{0}”。|
2480|     错误|     'let' is not allowed to be used as a name in 'let' or 'const' declarations.    "let" 不能用作 "let" 或 "const" 声明中的名称。|
2481|     错误|     Cannot initialize outer scoped variable '{0}' in the same scope as block scoped declaration '{1}'.    无法在块范围声明“{1}”所在的范围内初始化外部范围变量“{0}”。|
2483|     错误|     The left-hand side of a 'for...of' statement cannot use a type annotation.    "for...of" 语句的左侧不能使用类型批注。|
2484|     错误|     Export declaration conflicts with exported declaration of '{0}'    导出声明与“{0}”的导出声明冲突|
2487|     错误|     The left-hand side of a 'for...of' statement must be a variable or a property access.    "for...of" 语句左侧无效。|
2488|     错误|     Type must have a 'Symbol.iterator' method that returns an iterator.    类型必须具有返回迭代器的 "Symbol.iterator" 方法。|
2489|     错误|     An iterator must have a 'next()' method.    迭代器必须具有 "next()" 方法。|
2490|     错误|     The type returned by the 'next()' method of an iterator must have a 'value' property.    迭代器的 "next()" 方法返回的类型必须具有 "value" 属性。|
2491|     错误|     The left-hand side of a 'for...in' statement cannot be a destructuring pattern.    "for...in" 语句的左侧不能为析构模式。|
2492|     错误|     Cannot redeclare identifier '{0}' in catch clause    无法在 catch 子句中重新声明标识符“{0}”|
2493|     错误|     Tuple type '{0}' with length '{1}' cannot be assigned to tuple with length '{2}'.    不能将长度为“{1}”的元组类型“{0}”分配给长度为“{2}”的元组。|
2494|     错误|     Using a string in a 'for...of' statement is only supported in ECMAScript 5 and higher.    仅 ECMAScript 5 和更高版本支持在 "for...of" 语句中使用字符串。|
2495|     错误|     Type '{0}' is not an array type or a string type.    类型“{0}”不是数组类型或字符串类型。|
2496|     错误|     The 'arguments' object cannot be referenced in an arrow function in ES3 and ES5. Consider using a standard function expression.    ES3 和 ES5 中的箭头函数不能引用 "arguments" 对象。请考虑使用标准函数表达式。|
2497|     错误|     Module '{0}' resolves to a non-module entity and cannot be imported using this construct.    模块“{0}”解析为非模块实体，且不能使用此构造导入。|
2498|     错误|     Module '{0}' uses 'export =' and cannot be used with 'export *'.    模块“{0}”使用 "export =" 且无法与 "export*" 一起使用。|
2499|     错误|     An interface can only extend an identifier/qualified-name with optional type arguments.    接口只能扩展具有可选类型参数的标识符/限定名称。|
2500|     错误|     A class can only implement an identifier/qualified-name with optional type arguments.    类只能实现具有可选类型参数的标识符/限定名称。|
2501|     错误|     A rest element cannot contain a binding pattern.    rest 元素不能包含绑定模式。|
2502|     错误|     '{0}' is referenced directly or indirectly in its own type annotation.    “{0}”在其自身的类型批注中得到直接或间接引用。|
2503|     错误|     Cannot find namespace '{0}'.    找不到命名空间“{0}”。|
2505|     错误|     A generator cannot have a 'void' type annotation.    生成器不能具有 "void" 类型批注。|
2506|     错误|     '{0}' is referenced directly or indirectly in its own base expression.    “{0}”在其自身的基表达式中得到直接或间接引用。|
2507|     错误|     Type '{0}' is not a constructor function type.    类型“{0}”不是构造函数类型。|
2508|     错误|     No base constructor has the specified number of type arguments.    没有任何基构造函数具有指定数量的类型参数。|
2509|     错误|     Base constructor return type '{0}' is not a class or interface type.    基构造函数返回类型“{0}”不是类或接口类型。|
2510|     错误|     Base constructors must all have the same return type.    所有的基构造函数必须具有相同的返回类型。|
2511|     错误|     Cannot create an instance of the abstract class '{0}'.    无法创建抽象类“{0}”的实例。|
2512|     错误|     Overload signatures must all be abstract or non-abstract.    重载签名必须全部为抽象签名或非抽象签名。|
2513|     错误|     Abstract method '{0}' in class '{1}' cannot be accessed via super expression.    无法通过 super 表达式访问“{1}”类中的“{0}”抽象方法。|
2514|     错误|     Classes containing abstract methods must be marked abstract.    包含抽象方法的类必须标记为抽象。|
2515|     错误|     Non-abstract class '{0}' does not implement inherited abstract member '{1}' from class '{2}'.    非抽象类“{0}”不会实现继承自“{2}”类的抽象成员“{1}”。|
2516|     错误|     All declarations of an abstract method must be consecutive.    抽象方法的所有声明必须是连续的。|
2517|     错误|     Cannot assign an abstract constructor type to a non-abstract constructor type.    无法将抽象构造函数类型分配给非抽象构造函数类型。|
2518|     错误|     A 'this'-based type guard is not compatible with a parameter-based type guard.    A 'this'-based type guard is not compatible with a parameter-based type guard.|
2520|     错误|     Duplicate identifier '{0}'. Compiler uses declaration '{1}' to support async functions.    标识符“{0}”重复。编译器使用“{1}”声明来支持异步函数。|
2521|     错误|     Expression resolves to variable declaration '{0}' that compiler uses to support async functions.    表达式解析为编译器用于支持异步函数的变量声明“{0}”。|
2522|     错误|     The 'arguments' object cannot be referenced in an async function or method in ES3 and ES5. Consider using a standard function or method.    无法在异步箭头函数中引用 "arguments" 对象。请考虑使用标准的异步函数表达式。|
2523|     错误|     'yield' expressions cannot be used in a parameter initializer.    不能在参数初始化表达式中使用 "yield" 表达式。|
2524|     错误|     'await' expressions cannot be used in a parameter initializer.    不能在参数初始化表达式中使用 "await" 表达式。|
2525|     错误|     Initializer provides no value for this binding element and the binding element has no default value.    初始化表达式没有为此绑定元素提供此任何值，且该绑定元素没有默认值。|
2526|     错误|     A 'this' type is available only in a non-static member of a class or interface.    "this" 类型仅在类或接口的非静态成员中可用。|
2527|     错误|     The inferred type of '{0}' references an inaccessible 'this' type. A type annotation is necessary.    “{0}”的推断类型引用不可访问的 "this" 类型。需要类型批注。|
2528|     错误|     A module cannot have multiple default exports.    一个模块不能具有多个默认导出。|
2529|     错误|     Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module containing async functions.    Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module containing async functions.|
2530|     错误|     Property '{0}' is incompatible with index signature.|
2531|     错误|     Object is possibly 'null'.|
2532|     错误|     Object is possibly 'undefined'.|
2533|     错误|     Object is possibly 'null' or 'undefined'.|
2534|     错误|     A function returning 'never' cannot have a reachable end point.|
2535|     错误|     Enum type '{0}' has members with initializers that are not literals.|
2536|     错误|     Type '{0}' cannot be used to index type '{1}'.|
2537|     错误|     Type '{0}' has no matching index signature for type '{1}'.|
2538|     错误|     Type '{0}' cannot be used as an index type.|
2539|     错误|     Cannot assign to '{0}' because it is not a variable.|
2540|     错误|     Cannot assign to '{0}' because it is a constant or a read-only property.|
2541|     错误|     The target of an assignment must be a variable or a property access.|
2542|     错误|     Index signature in type '{0}' only permits reading.|
2543|     错误|     Duplicate identifier '_newTarget'. Compiler uses variable declaration '_newTarget' to capture 'new.target' meta-property reference.|
2544|     错误|     Expression resolves to variable declaration '_newTarget' that compiler uses to capture 'new.target' meta-property reference.|
2600|     错误|     JSX element attributes type '{0}' may not be a union type.    JSX element attributes type '{0}' may not be a union type.|
2601|     错误|     The return type of a JSX element constructor must return an object type.    JSX 元素构造函数的返回类型必须返回对象类型。|
2602|     错误|     JSX element implicitly has type 'any' because the global type 'JSX.Element' does not exist.    JSX 元素隐式具有类型 "any"，因为不存在全局类型 "JSX.Element"。|
2603|     错误|     Property '{0}' in type '{1}' is not assignable to type '{2}'    类型“{1}”中的属性“{0}”不可分配给类型“{2}”|
2604|     错误|     JSX element type '{0}' does not have any construct or call signatures.    JSX 元素类型“{0}”不具有任何构造签名或调用签名。|
2605|     错误|     JSX element type '{0}' is not a constructor function for JSX elements.    JSX 元素类型“{0}”不是 JSX 元素的构造函数。|
2606|     错误|     Property '{0}' of JSX spread attribute is not assignable to target property.    JSX 展开特性的“{0}”属性不能分配给目标属性。|
2607|     错误|     JSX element class does not support attributes because it does not have a '{0}' property    JSX 元素类不支持特性，因为它不具有“{0}”属性|
2608|     错误|     The global type 'JSX.{0}' may not have more than one property    全局类型“JSX.{0}”不可以具有多个属性|
2609|     错误|     JSX spread child must be an array type.|
2650|     错误|     Cannot emit namespaced JSX elements in React    无法发出 React 中带命名空间的 JSX 元素|
2651|     错误|     A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums.    枚举声明中的成员初始化表达式不能引用在其后声明的成员(包括在其他枚举中定义的成员)。|
2652|     错误|     Merged declaration '{0}' cannot include a default export declaration. Consider adding a separate 'export default {0}' declaration instead.    合并声明“{0}”不能包含默认导出声明。请考虑改为添加一个独立的“导出默认 {0}”声明。|
2653|     错误|     Non-abstract class expression does not implement inherited abstract member '{0}' from class '{1}'.    非抽象类表达式不会实现继承自“{1}”类的抽象成员“{0}”。|
2654|     错误|     Exported external package typings file cannot contain tripleslash references. Please contact the package author to update the package definition.    导出的外部包键入文件不能包含三斜线引用。请与包作者联系或更新包定义。|
2656|     错误|     Exported external package typings file '{0}' is not a module. Please contact the package author to update the package definition.    导出的外部包键入文件“{0}”不是一个模块。请与包作者联系或更新包定义。|
2657|     错误|     JSX expressions must have one parent element    JSX 表达式必须具有一个父元素|
2658|     错误|     Type '{0}' provides no match for the signature '{1}'    类型“{0}”提供程序与签名“{1}”不匹配|
2659|     错误|     'super' is only allowed in members of object literal expressions when option 'target' is 'ES2015' or higher.    'super' is only allowed in members of object literal expressions when option 'target' is 'ES2015' or higher.|
2660|     错误|     'super' can only be referenced in members of derived classes or object literal expressions.    'super' can only be referenced in members of derived classes or object literal expressions.|
2661|     错误|     Cannot export '{0}'. Only local declarations can be exported from a module.    Cannot re-export name that is not defined in the module.|
2662|     错误|     Cannot find name '{0}'. Did you mean the static member '{1}.{0}'?    Cannot find name '{0}'. Did you mean the static member '{1}.{0}'?|
2663|     错误|     Cannot find name '{0}'. Did you mean the instance member 'this.{0}'?    Cannot find name '{0}'. Did you mean the instance member 'this.{0}'?|
2664|     错误|     Invalid module name in augmentation, module '{0}' cannot be found.    Invalid module name in augmentation, module '{0}' cannot be found.|
2665|     错误|     Invalid module name in augmentation. Module '{0}' resolves to an untyped module at '{1}', which cannot be augmented.    Module augmentation cannot introduce new names in the top level scope.|
2666|     错误|     Exports and export assignments are not permitted in module augmentations.    Exports and export assignments are not permitted in module augmentations.|
2667|     错误|     Imports are not permitted in module augmentations. Consider moving them to the enclosing external module.    Imports are not permitted in module augmentations. Consider moving them to the enclosing external module.|
2668|     错误|     'export' modifier cannot be applied to ambient modules and module augmentations since they are always visible.    'export' modifier cannot be applied to ambient modules and module augmentations since they are always visible.|
2669|     错误|     Augmentations for the global scope can only be directly nested in external modules or ambient module declarations.    Augmentations for the global scope can only be directly nested in external modules or ambient module declarations.|
2670|     错误|     Augmentations for the global scope should have 'declare' modifier unless they appear in already ambient context.    Augmentations for the global scope should have 'declare' modifier unless they appear in already ambient context.|
2671|     错误|     Cannot augment module '{0}' because it resolves to a non-module entity.    Cannot augment module '{0}' because it resolves to a non-module entity.|
2672|     错误|     Cannot assign a '{0}' constructor type to a '{1}' constructor type.|
2673|     错误|     Constructor of class '{0}' is private and only accessible within the class declaration.|
2674|     错误|     Constructor of class '{0}' is protected and only accessible within the class declaration.|
2675|     错误|     Cannot extend a class '{0}'. Class constructor is marked as private.|
2676|     错误|     Accessors must both be abstract or non-abstract.|
2677|     错误|     A type predicate's type must be assignable to its parameter's type.|
2678|     错误|     Type '{0}' is not comparable to type '{1}'.|
2679|     错误|     A function that is called with the 'new' keyword cannot have a 'this' type that is 'void'.|
2680|     错误|     A 'this' parameter must be the first parameter.|
2681|     错误|     A constructor cannot have a 'this' parameter.|
2682|     错误|     'get' and 'set' accessor must have the same 'this' type.|
2683|     错误|     'this' implicitly has type 'any' because it does not have a type annotation.|
2684|     错误|     The 'this' context of type '{0}' is not assignable to method's 'this' of type '{1}'.|
2685|     错误|     The 'this' types of each signature are incompatible.|
2686|     错误|     '{0}' refers to a UMD global, but the current file is a module. Consider adding an import instead.|
2687|     错误|     All declarations of '{0}' must have identical modifiers.|
2688|     错误|     Cannot find type definition file for '{0}'.|
2689|     错误|     Cannot extend an interface '{0}'. Did you mean 'implements'?|
2690|     错误|     A class must be declared after its base class.|
2691|     错误|     An import path cannot end with a '{0}' extension. Consider importing '{1}' instead.|
2692|     错误|     '{0}' is a primitive, but '{1}' is a wrapper object. Prefer using '{0}' when possible.|
2693|     错误|     '{0}' only refers to a type, but is being used as a value here.|
2694|     错误|     Namespace '{0}' has no exported member '{1}'.|
2695|     错误|     Left side of comma operator is unused and has no side effects.|
2696|     错误|     The 'Object' type is assignable to very few other types. Did you mean to use the 'any' type instead?|
2697|     错误|     An async function or method must return a 'Promise'. Make sure you have a declaration for 'Promise' or include 'ES2015' in your --lib option.|
2698|     错误|     Spread types may only be created from object types.|
2700|     错误|     Rest types may only be created from object types.|
2701|     错误|     The target of an object rest assignment must be a variable or a property access.|
2702|     错误|     '{0}' only refers to a type, but is being used as a namespace here.|
2703|     错误|     The operand of a delete operator must be a property reference|
2704|     错误|     The operand of a delete operator cannot be a read-only property|
4000|     错误|     Import declaration '{0}' is using private name '{1}'.    导入声明“{0}”使用的是专用名称“{1}”。|
4002|     错误|     Type parameter '{0}' of exported class has or is using private name '{1}'.    导出类的类型参数“{0}”具有或正在使用专用名称“{1}”。|
4004|     错误|     Type parameter '{0}' of exported interface has or is using private name '{1}'.    导出接口的类型参数“{0}”具有或正在使用专用名称“{1}”。|
4006|     错误|     Type parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.    导出接口中的构造函数签名的类型参数“{0}”具有或正在使用专用名称“{1}”。|
4008|     错误|     Type parameter '{0}' of call signature from exported interface has or is using private name '{1}'.    导出接口中的调用签名的类型参数“{0}”具有或正在使用专用名称“{1}”。|
4010|     错误|     Type parameter '{0}' of public static method from exported class has or is using private name '{1}'.    导出类中的公共静态方法的类型参数“{0}”具有或正在使用专用名称“{1}”。|
4012|     错误|     Type parameter '{0}' of public method from exported class has or is using private name '{1}'.    导出类中的公共方法的类型参数“{0}”具有或正在使用专用名称“{1}”。|
4014|     错误|     Type parameter '{0}' of method from exported interface has or is using private name '{1}'.    导出接口中的方法的类型参数“{0}”具有或正在使用专用名称“{1}”。|
4016|     错误|     Type parameter '{0}' of exported function has or is using private name '{1}'.    导出函数的类型参数“{0}”具有或正在使用专用名称“{1}”。|
4019|     错误|     Implements clause of exported class '{0}' has or is using private name '{1}'.    导出的类“{0}”的 Implements 子句具有或正在使用专用名称“{1}”。|
4020|     错误|     Extends clause of exported class '{0}' has or is using private name '{1}'.    导出的类“{0}”的 extends 子句具有或正在使用专用名称“{1}”。|
4022|     错误|     Extends clause of exported interface '{0}' has or is using private name '{1}'.    导出接口“{0}”的 extends 子句具有或正在使用专用名称“{1}”。|
4023|     错误|     Exported variable '{0}' has or is using name '{1}' from external module {2} but cannot be named.    导出的变量“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。|
4024|     错误|     Exported variable '{0}' has or is using name '{1}' from private module '{2}'.    导出的变量“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。|
4025|     错误|     Exported variable '{0}' has or is using private name '{1}'.    导出的变量“{0}”具有或正在使用专用名称“{1}”。|
4026|     错误|     Public static property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.    导出类的公共静态属性“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。|
4027|     错误|     Public static property '{0}' of exported class has or is using name '{1}' from private module '{2}'.    导出类的公共静态属性“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”。|
4028|     错误|     Public static property '{0}' of exported class has or is using private name '{1}'.    导出类的公共静态属性“{0}”具有或正在使用专用名称“{1}”。|
4029|     错误|     Public property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.    导出类的公共属性“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。|
4030|     错误|     Public property '{0}' of exported class has or is using name '{1}' from private module '{2}'.    导出类的公共属性“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。|
4031|     错误|     Public property '{0}' of exported class has or is using private name '{1}'.    导出类的公共属性“{0}”具有或正在使用专用名称“{1}”。|
4032|     错误|     Property '{0}' of exported interface has or is using name '{1}' from private module '{2}'.    导出接口的属性“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。|
4033|     错误|     Property '{0}' of exported interface has or is using private name '{1}'.    导出接口的属性“{0}”具有或正在使用专用名称“{1}”。|
4034|     错误|     Parameter '{0}' of public static property setter from exported class has or is using name '{1}' from private module '{2}'.    导出类中的公共静态属性 setter 的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。|
4035|     错误|     Parameter '{0}' of public static property setter from exported class has or is using private name '{1}'.    导出类中的公共静态属性 setter 的参数“{0}”具有或正在使用专用名称“{1}”。|
4036|     错误|     Parameter '{0}' of public property setter from exported class has or is using name '{1}' from private module '{2}'.    导出类中的公共属性 setter 的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。|
4037|     错误|     Parameter '{0}' of public property setter from exported class has or is using private name '{1}'.    导出类中的公共属性 setter 的参数“{0}”具有或正在使用专用名称“{1}”。|
4038|     错误|     Return type of public static property getter from exported class has or is using name '{0}' from external module {1} but cannot be named.    导出类中的公共静态属性 getter 的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。|
4039|     错误|     Return type of public static property getter from exported class has or is using name '{0}' from private module '{1}'.    导出类中的公共静态属性 getter 的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。|
4040|     错误|     Return type of public static property getter from exported class has or is using private name '{0}'.    导出类中的公共静态属性 getter 的返回类型具有或正在使用专用名称“{0}”。|
4041|     错误|     Return type of public property getter from exported class has or is using name '{0}' from external module {1} but cannot be named.    导出类中的公共属性 getter 的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。|
4042|     错误|     Return type of public property getter from exported class has or is using name '{0}' from private module '{1}'.    导出类中的公共属性 getter 的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。|
4043|     错误|     Return type of public property getter from exported class has or is using private name '{0}'.    导出类中的公共属性 getter 的返回类型具有或正在使用专用名称“{0}”。|
4044|     错误|     Return type of constructor signature from exported interface has or is using name '{0}' from private module '{1}'.    导出接口中的构造函数签名的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。|
4045|     错误|     Return type of constructor signature from exported interface has or is using private name '{0}'.    导出接口中的构造函数签名的返回类型具有或正在使用专用名称“{0}”。|
4046|     错误|     Return type of call signature from exported interface has or is using name '{0}' from private module '{1}'.    导出接口中的调用签名的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。|
4047|     错误|     Return type of call signature from exported interface has or is using private name '{0}'.    导出接口中的调用签名的返回类型具有或正在使用专用名称“{0}”。|
4048|     错误|     Return type of index signature from exported interface has or is using name '{0}' from private module '{1}'.    导出接口中的索引签名的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。|
4049|     错误|     Return type of index signature from exported interface has or is using private name '{0}'.    导出接口中的索引签名的返回类型具有或正在使用专用名称“{0}”。|
4050|     错误|     Return type of public static method from exported class has or is using name '{0}' from external module {1} but cannot be named.    导出类中的公共静态方法的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。|
4051|     错误|     Return type of public static method from exported class has or is using name '{0}' from private module '{1}'.    导出类中的公共静态方法的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。|
4052|     错误|     Return type of public static method from exported class has or is using private name '{0}'.    导出类中的公共静态方法的返回类型具有或正在使用专用名称“{0}”。|
4053|     错误|     Return type of public method from exported class has or is using name '{0}' from external module {1} but cannot be named.    导出类中的公共方法的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。|
4054|     错误|     Return type of public method from exported class has or is using name '{0}' from private module '{1}'.    导出类中的公共方法的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。|
4055|     错误|     Return type of public method from exported class has or is using private name '{0}'.    导出类中的公共方法的返回类型具有或正在使用专用名称“{0}”。|
4056|     错误|     Return type of method from exported interface has or is using name '{0}' from private module '{1}'.    导出接口中的方法的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。|
4057|     错误|     Return type of method from exported interface has or is using private name '{0}'.    导出接口中的方法的返回类型具有或正在使用专用名称“{0}”。|
4058|     错误|     Return type of exported function has or is using name '{0}' from external module {1} but cannot be named.    导出函数的返回类型具有或正在使用外部模块“{1}”中的名称“{0}”，但不能为其命名。|
4059|     错误|     Return type of exported function has or is using name '{0}' from private module '{1}'.    导出函数的返回类型具有或正在使用私有模块“{1}”中的名称“{0}”。|
4060|     错误|     Return type of exported function has or is using private name '{0}'.    导出函数的返回类型具有或正在使用专用名称“{0}”。|
4061|     错误|     Parameter '{0}' of constructor from exported class has or is using name '{1}' from external module {2} but cannot be named.    导出类中的构造函数的参数“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。|
4062|     错误|     Parameter '{0}' of constructor from exported class has or is using name '{1}' from private module '{2}'.    导出类中的构造函数的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。|
4063|     错误|     Parameter '{0}' of constructor from exported class has or is using private name '{1}'.    导出类中的构造函数的参数“{0}”具有或正在使用专用名称“{1}”。|
4064|     错误|     Parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'.    导出接口中的构造函数签名的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。|
4065|     错误|     Parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.    导出接口中的构造函数签名的参数“{0}”具有或正在使用专用名称“{1}”。|
4066|     错误|     Parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'.    导出接口中的调用签名的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。|
4067|     错误|     Parameter '{0}' of call signature from exported interface has or is using private name '{1}'.    导出接口中的调用签名的参数“{0}”具有或正在使用专用名称“{1}”。|
4068|     错误|     Parameter '{0}' of public static method from exported class has or is using name '{1}' from external module {2} but cannot be named.    导出类中的公共静态方法的参数“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。|
4069|     错误|     Parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'.    导出类中的公共静态方法的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。|
4070|     错误|     Parameter '{0}' of public static method from exported class has or is using private name '{1}'.    导出类中的公共静态方法的参数“{0}”具有或正在使用专用名称“{1}”。|
4071|     错误|     Parameter '{0}' of public method from exported class has or is using name '{1}' from external module {2} but cannot be named.    导出类中的公共方法的参数“{0}”具有或正在使用外部模块“{2}”中的名称“{1}”，但不能为其命名。|
4072|     错误|     Parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'.    导出类中的公共方法的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。|
4073|     错误|     Parameter '{0}' of public method from exported class has or is using private name '{1}'.    导出类中的公共方法的参数“{0}”具有或正在使用专用名称“{1}”。|
4074|     错误|     Parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'.    导出接口中的方法的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。|
4075|     错误|     Parameter '{0}' of method from exported interface has or is using private name '{1}'.    导出接口中的方法的参数“{0}”具有或正在使用专用名称“{1}”。|
4076|     错误|     Parameter '{0}' of exported function has or is using name '{1}' from external module {2} but cannot be named.    导出函数的参数“{0}”具有或正在使用外部模块 {2} 中的名称“{1}”，但不能为其命名。|
4077|     错误|     Parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'.    导出函数的参数“{0}”具有或正在使用私有模块“{2}”中的名称“{1}”。|
4078|     错误|     Parameter '{0}' of exported function has or is using private name '{1}'.    导出函数的参数“{0}”具有或正在使用专用名称“{1}”。|
4081|     错误|     Exported type alias '{0}' has or is using private name '{1}'.    导出的类型别名“{0}”已经或正在使用专用名称“{1}”。|
4082|     错误|     Default export of the module has or is using private name '{0}'.    模块的默认导出具有或正在使用专用名称“{0}”。|
4083|     错误|     Type parameter '{0}' of exported type alias has or is using private name '{1}'.|
4090|     信息|     Conflicting definitions for '{0}' found at '{1}' and '{2}'. Consider installing a specific version of this library to resolve the conflict.|
4091|     错误|     Parameter '{0}' of index signature from exported interface has or is using name '{1}' from private module '{2}'.|
4092|     错误|     Parameter '{0}' of index signature from exported interface has or is using private name '{1}'.|
5001|     错误|     The current host does not support the '{0}' option.    当前主机不支持“{0}”选项。|
5009|     错误|     Cannot find the common subdirectory path for the input files.    找不到输入文件的公共子目录路径。|
5010|     错误|     File specification cannot end in a recursive directory wildcard ('**'): '{0}'.|
5011|     错误|     File specification cannot contain multiple recursive directory wildcards ('**'): '{0}'.|
5012|     错误|     Cannot read file '{0}': {1}    无法读取文件“{0}”: {1}|
5013|     错误|     Unsupported file encoding.    文件编码不受支持。|
5014|     错误|     Failed to parse file '{0}': {1}.    未能分析文件“{0}”: {1}。|
5023|     错误|     Unknown compiler option '{0}'.    未知的编译器选项“{0}”。|
5024|     错误|     Compiler option '{0}' requires a value of type {1}.    编译器选项“{0}”需要类型 {1} 的值。|
5033|     错误|     Could not write file '{0}': {1}    无法写入文件“{0}”: {1}|
5042|     错误|     Option 'project' cannot be mixed with source files on a command line.    选项 "project" 在命令行上不能与源文件混合使用。|
5047|     错误|     Option 'isolatedModules' can only be used when either option '--module' is provided or option 'target' is 'ES2015' or higher.    选项 "isolatedModules" 只可在提供了选项 "--module" 或者选项 "target" 是 "ES2015" 或更高版本时使用。|
5051|     错误|     Option '{0} can only be used when either option '--inlineSourceMap' or option '--sourceMap' is provided.    仅当提供了选项 "--inlineSources" 或选项 "--sourceMap" 时，才能使用选项 "inlineSources"。|
5052|     错误|     Option '{0}' cannot be specified without specifying option '{1}'.    无法在不指定选项“{1}”的情况下指定选项“{0}”。|
5053|     错误|     Option '{0}' cannot be specified with option '{1}'.    选项“{0}”不能与选项“{1}”同时指定。|
5054|     错误|     A 'tsconfig.json' file is already defined at: '{0}'.    已在“{0}”中定义了 "tsconfig.json" 文件。|
5055|     错误|     Cannot write file '{0}' because it would overwrite input file.    无法写入文件“{0}”，因为它会覆盖输入文件。|
5056|     错误|     Cannot write file '{0}' because it would be overwritten by multiple input files.    无法写入文件“{0}”，因为它会被多个输入文件覆盖。|
5057|     错误|     Cannot find a tsconfig.json file at the specified directory: '{0}'    无法在指定目录找到 tsconfig.json 文件:“{0}”|
5058|     错误|     The specified path does not exist: '{0}'    指定的路径不存在:“{0}”|
5059|     错误|     Invalid value for '--reactNamespace'. '{0}' is not a valid identifier.    Invalide value for '--reactNamespace'. '{0}' is not a valid identifier.|
5060|     错误|     Option 'paths' cannot be used without specifying '--baseUrl' option.|
5061|     错误|     Pattern '{0}' can have at most one '*' character|
5062|     错误|     Substitution '{0}' in pattern '{1}' in can have at most one '*' character|
5063|     错误|     Substitutions for pattern '{0}' should be an array.|
5064|     错误|     Substitution '{0}' for pattern '{1}' has incorrect type, expected 'string', got '{2}'.|
5065|     错误|     File specification cannot contain a parent directory ('..') that appears after a recursive directory wildcard ('**'): '{0}'.|
5066|     错误|     Substitutions for pattern '{0}' shouldn't be an empty array.|
5067|     错误|     Invalid value for 'jsxFactory'. '{0}' is not a valid identifier or qualified-name.|
6001|     信息|     Concatenate and emit output to single file.    连接输出并将其发出到单个文件。|
6002|     信息|     Generates corresponding '.d.ts' file.    生成相应的 ".d.ts" 文件。|
6003|     信息|     Specify the location where debugger should locate map files instead of generated locations.    指定调试程序应放置映射文件的位置而不是生成的位置。|
6004|     信息|     Specify the location where debugger should locate TypeScript files instead of source locations.    指定调试程序应放置 TypeScript 文件的位置而不是源位置。|
6005|     信息|     Watch input files.    监视输入文件。|
6006|     信息|     Redirect output structure to the directory.    将输出结构重定向到目录。|
6007|     信息|     Do not erase const enum declarations in generated code.    请勿清除生成代码中的常数枚举声明。|
6008|     信息|     Do not emit outputs if any errors were reported.    如果报告了任何错误，请不要发出输出。|
6009|     信息|     Do not emit comments to output.    请勿将注释发出到输出。|
6010|     信息|     Do not emit outputs.    请勿发出输出。|
6011|     信息|     Allow default imports from modules with no default export. This does not affect code emit, just typechecking.    允许从不带默认输出的模块中默认输入。这不会影响代码发出，只是类型检查。|
6012|     信息|     Skip type checking of declaration files.|
6015|     信息|     Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'    指定 ECMAScript 目标版本: "ES3" (默认)、"ES5" 或 "ES2015" (实验)|
6016|     信息|     Specify module code generation: 'commonjs', 'amd', 'system', 'umd' or 'es2015'    指定模块代码生成: "commonjs"、"amd"、"system"、"umd" 或 "es2015"|
6017|     信息|     Print this message.    打印此消息。|
6019|     信息|     Print the compiler's version.    打印编译器的版本。|
6020|     信息|     Compile the project in the given directory.    在指定目录中编译项目。|
6023|     信息|     Syntax: {0}    语法: {0}|
6024|     信息|     options    选项|
6025|     信息|     file    文件|
6026|     信息|     Examples: {0}    示例: {0}|
6027|     信息|     Options:    选项:|
6029|     信息|     Version {0}    版本 {0}|
6030|     信息|     Insert command line options and files from a file.    从文件插入命令行选项和文件。|
6032|     信息|     File change detected. Starting incremental compilation...    检测到文件更改。正在启动增量编译...|
6034|     信息|     KIND    种类|
6035|     信息|     FILE    文件|
6036|     信息|     VERSION    版本|
6037|     信息|     LOCATION    位置|
6038|     信息|     DIRECTORY    目录|
6039|     信息|     STRATEGY|
6042|     信息|     Compilation complete. Watching for file changes.    编译完成。查看文件更改。|
6043|     信息|     Generates corresponding '.map' file.    生成相应的 ".map" 文件。|
6044|     错误|     Compiler option '{0}' expects an argument.    编译器选项“{0}”需要参数。|
6045|     错误|     Unterminated quoted string in response file '{0}'.    响应文件“{0}”中引号不配对。|
6046|     错误|     Argument for '{0}' option must be: {1}    Argument for '--module' option must be 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'none'.|
6048|     错误|     Locale must be of the form or - . For example '{0}' or '{1}'.    区域设置必须采用 <语言> 或 <语言>-<区域> 形式。例如“{0}”或“{1}”。|
6049|     错误|     Unsupported locale '{0}'.    区域设置“{0}”不受支持。|
6050|     错误|     Unable to open file '{0}'.    无法打开文件“{0}”。|
6051|     错误|     Corrupted locale file {0}.    区域设置文件 {0} 已损坏。|
6052|     信息|     Raise error on expressions and declarations with an implied 'any' type.    对具有隐式 "any" 类型的表达式和声明引发错误。|
6053|     错误|     File '{0}' not found.    找不到文件“{0}”。|
6054|     错误|     File '{0}' has unsupported extension. The only supported extensions are {1}.    不支持文件“{0}”的扩展名。唯一支持的扩展名为 {1}。|
6055|     信息|     Suppress noImplicitAny errors for indexing objects lacking index signatures.    抑制缺少索引签名的索引对象的 noImplicitAny 错误。|
6056|     信息|     Do not emit declarations for code that has an '@internal' annotation.    请勿对具有 "@internal" 注释的代码发出声明。|
6058|     信息|     Specify the root directory of input files. Use to control the output directory structure with --outDir.    指定输入文件的根目录。与 --outDir 一起用于控制输出目录结构。|
6059|     错误|     File '{0}' is not under 'rootDir' '{1}'. 'rootDir' is expected to contain all source files.    文件“{0}”不在 "rootDir"“{1}”下。"rootDir" 应包含所有源文件。|
6060|     信息|     Specify the end of line sequence to be used when emitting files: 'CRLF' (dos) or 'LF' (unix).    指定发出文件时要使用的行序列结尾: "CRLF" (dos)或 "LF" (unix)。|
6061|     信息|     NEWLINE    换行符|
6064|     错误|     Option '{0}' can only be specified in 'tsconfig.json' file.|
6065|     信息|     Enables experimental support for ES7 decorators.    对 ES7 修饰器启用实验支持。|
6066|     信息|     Enables experimental support for emitting type metadata for decorators.    对发出修饰器的类型元数据启用实验支持。|
6068|     信息|     Enables experimental support for ES7 async functions.    对 ES7 异步函数启用实验支持。|
6069|     信息|     Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6).    指定模块解决策略: "node" (Node.js) 或 "classic" (TypeScript pre-1.6)。|
6070|     信息|     Initializes a TypeScript project and creates a tsconfig.json file.    初始化 TypeScript 项目并创建 tsconfig.json 文件。|
6071|     信息|     Successfully created a tsconfig.json file.    已成功创建 tsconfig.json 文件。|
6072|     信息|     Suppress excess property checks for object literals.    取消对象文字的多余属性检查。|
6073|     信息|     Stylize errors and messages using color and context. (experimental)    使用颜色和上下文风格化错误和消息。(实验)|
6074|     信息|     Do not report errors on unused labels.    不报告有关未使用的标签的错误。|
6075|     信息|     Report error when not all code paths in function return a value.    在函数中的所有代码路径并非都返回值时报告错误。|
6076|     信息|     Report errors for fallthrough cases in switch statement.    报告 switch 语句中遇到 fallthrough 情况的错误。|
6077|     信息|     Do not report errors on unreachable code.    不报告有关不可访问的代码的错误。|
6078|     信息|     Disallow inconsistently-cased references to the same file.    不允许对同一文件采用大小不一致的引用。|
6079|     信息|     Specify library files to be included in the compilation:|
6080|     信息|     Specify JSX code generation: 'preserve' or 'react'    指定 JSX 代码生成: "preserve" 或 "react"|
6081|     信息|     File '{0}' has an unsupported extension, so skipping it.    "--jsx" 的参数必须为 "preserve" 或 "react"。|
6082|     错误|     Only 'amd' and 'system' modules are supported alongside --{0}.    --{0} 旁仅支持 "amd" 和 "system" 模块。|
6083|     信息|     Base directory to resolve non-absolute module names.    允许编译 JavaScript 文件。|
6084|     信息|     Specify the object invoked for createElement and __spread when targeting 'react' JSX emit    Specifies the object invoked for createElement and__spread when targeting 'react' JSX emit|
6085|     信息|     Enable tracing of the name resolution process.|
6086|     信息|     ======== Resolving module '{0}' from '{1}'. ========|
6087|     信息|     Explicitly specified module resolution kind: '{0}'.|
6088|     信息|     Module resolution kind is not specified, using '{0}'.|
6089|     信息|     ======== Module name '{0}' was successfully resolved to '{1}'. ========|
6090|     信息|     ======== Module name '{0}' was not resolved. ========|
6091|     信息|     'paths' option is specified, looking for a pattern to match module name '{0}'.|
6092|     信息|     Module name '{0}', matched pattern '{1}'.|
6093|     信息|     Trying substitution '{0}', candidate module location: '{1}'.|
6094|     信息|     Resolving module name '{0}' relative to base url '{1}' - '{2}'.|
6095|     信息|     Loading module as file / folder, candidate module location '{0}', target file type '{1}'.|
6096|     信息|     File '{0}' does not exist.|
6097|     信息|     File '{0}' exist - use it as a name resolution result.|
6098|     信息|     Loading module '{0}' from 'node_modules' folder, target file type '{1}'.|
6099|     信息|     Found 'package.json' at '{0}'.|
6100|     信息|     'package.json' does not have a 'types' or 'main' field.|
6101|     信息|     'package.json' has '{0}' field '{1}' that references '{2}'.|
6102|     信息|     Allow javascript files to be compiled.|
6103|     错误|     Option '{0}' should have array of strings as a value.    Option '{0}' should have array of strings as a value.|
6104|     信息|     Checking if '{0}' is the longest matching prefix for '{1}' - '{2}'.|
6105|     信息|     Expected type of '{0}' field in 'package.json' to be 'string', got '{1}'.|
6106|     信息|     'baseUrl' option is set to '{0}', using this value to resolve non-relative module name '{1}'|
6107|     信息|     'rootDirs' option is set, using it to resolve relative module name '{0}'|
6108|     信息|     Longest matching prefix for '{0}' is '{1}'|
6109|     信息|     Loading '{0}' from the root dir '{1}', candidate location '{2}'|
6110|     信息|     Trying other entries in 'rootDirs'|
6111|     信息|     Module resolution using 'rootDirs' has failed|
6112|     信息|     Do not emit 'use strict' directives in module output.    Do not emit 'use strict' directives in module output.|
6113|     信息|     Enable strict null checks.|
6114|     错误|     Unknown option 'excludes'. Did you mean 'exclude'?|
6115|     信息|     Raise error on 'this' expressions with an implied 'any' type.|
6116|     信息|     ======== Resolving type reference directive '{0}', containing file '{1}', root directory '{2}'. ========|
6117|     信息|     Resolving using primary search paths...|
6118|     信息|     Resolving from node_modules folder...|
6119|     信息|     ======== Type reference directive '{0}' was successfully resolved to '{1}', primary: {2}. ========|
6120|     信息|     ======== Type reference directive '{0}' was not resolved. ========|
6121|     信息|     Resolving with primary search path '{0}'|
6122|     信息|     Root directory cannot be determined, skipping primary search paths.|
6123|     信息|     ======== Resolving type reference directive '{0}', containing file '{1}', root directory not set. ========|
6124|     信息|     Type declaration files to be included in compilation.|
6125|     信息|     Looking up in 'node_modules' folder, initial location '{0}'|
6126|     信息|     Containing file is not specified and root directory cannot be determined, skipping lookup in 'node_modules' folder.|
6127|     信息|     ======== Resolving type reference directive '{0}', containing file not set, root directory '{1}'. ========|
6128|     信息|     ======== Resolving type reference directive '{0}', containing file not set, root directory not set. ========|
6129|     错误|     The config file '{0}' found doesn't contain any source files.|
6130|     信息|     Resolving real path for '{0}', result '{1}'|
6131|     错误|     Cannot compile modules using option '{0}' unless the '--module' flag is 'amd' or 'system'.|
6132|     信息|     File name '{0}' has a '{1}' extension - stripping it|
6133|     错误|     '{0}' is declared but never used.|
6134|     信息|     Report errors on unused locals.|
6135|     信息|     Report errors on unused parameters.|
6136|     信息|     The maximum dependency depth to search under node_modules and load JavaScript files|
6137|     信息|     No types specified in 'package.json', so returning 'main' value of '{0}'|
6138|     错误|     Property '{0}' is declared but never used.|
6139|     信息|     Import emit helpers from 'tslib'.|
6140|     错误|     Auto discovery for typings is enabled in project '{0}'. Running extra resolution pass for module '{1}' using cache location '{2}'.|
6141|     信息|     Parse in strict mode and emit "use strict" for each source file|
6142|     错误|     Module '{0}' was resolved to '{1}', but '--jsx' is not set.|
6143|     错误|     Module '{0}' was resolved to '{1}', but '--allowJs' is not set.|
6144|     信息|     Module '{0}' was resolved as locally declared ambient module in file '{1}'.|
6145|     信息|     Module '{0}' was resolved as ambient module declared in '{1}' since this file was not modified.|
6146|     信息|     Specify the JSX factory function to use when targeting 'react' JSX emit, e.g. 'React.createElement' or 'h'.|
6147|     信息|     Resolution for module '{0}' was found in cache.|
6148|     信息|     Directory '{0}' does not exist, skipping all lookups in it.|
7005|     错误|     Variable '{0}' implicitly has an '{1}' type.    变量“{0}”隐式具有“{1}”类型。|
7006|     错误|     Parameter '{0}' implicitly has an '{1}' type.    参数“{0}”隐式具有“{1}”类型。|
7008|     错误|     Member '{0}' implicitly has an '{1}' type.    成员“{0}”隐式包含类型“{1}”。|
7009|     错误|     'new' expression, whose target lacks a construct signature, implicitly has an 'any' type.    其目标缺少构造签名的 "new" 表达式隐式具有 "any" 类型。|
7010|     错误|     '{0}', which lacks return-type annotation, implicitly has an '{1}' return type.    缺少返回类型批注的“{0}”隐式具有“{1}”返回类型。|
7011|     错误|     Function expression, which lacks return-type annotation, implicitly has an '{0}' return type.    缺少返回类型批注的函数表达式隐式具有“{0}”返回类型。|
7013|     错误|     Construct signature, which lacks return-type annotation, implicitly has an 'any' return type.    缺少返回类型批注的构造签名隐式具有返回类型 "any"。|
7015|     错误|     Element implicitly has an 'any' type because index expression is not of type 'number'.    Element implicitly has an 'any' type because index expression is not of type 'number'.|
7016|     错误|     Could not find a declaration file for module '{0}'. '{1}' implicitly has an 'any' type.    属性“{0}”隐式具有类型 "any"，因为其 "set" 访问器缺少类型批注。|
7017|     错误|     Element implicitly has an 'any' type because type '{0}' has no index signature.    对象类型的索引签名隐式地含有 "any" 类型。|
7018|     错误|     Object literal's property '{0}' implicitly has an '{1}' type.    对象文字的属性“{0}”隐式含有“{1}”类型。|
7019|     错误|     Rest parameter '{0}' implicitly has an 'any[]' type.    Rest 参数“{0}”隐式具有 "any[]" 类型。|
7020|     错误|     Call signature, which lacks return-type annotation, implicitly has an 'any' return type.    缺少返回类型批注的调用签名隐式具有返回类型 "any"。|
7022|     错误|     '{0}' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.    “{0}”隐式具有类型 "any"，因为它不具有类型批注，且在其自身的初始化表达式中得到直接或间接引用。|
7023|     错误|     '{0}' implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.    由于“{0}'”不具有返回类型批注并且在它的一个返回表达式中得到直接或间接引用，因此它隐式具有返回类型 "any"。|
7024|     错误|     Function implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.    由于函数不具有返回类型批注并且在它的一个返回表达式中得到直接或间接引用，因此它隐式具有返回类型 "any"。|
7025|     错误|     Generator implicitly has type '{0}' because it does not yield any values. Consider supplying a return type.    生成器隐式具有类型“{0}”，因为它不生成任何值。请考虑提供一个返回类型。|
7026|     错误|     JSX element implicitly has type 'any' because no interface 'JSX.{0}' exists    JSX 元素隐式具有类型 "any"，因为不存在接口“JSX.{0}”|
7027|     错误|     Unreachable code detected.    检测到无法访问的代码。|
7028|     错误|     Unused label.    未使用的标签。|
7029|     错误|     Fallthrough case in switch.    switch 语句中的 Fallthrough 情况。|
7030|     错误|     Not all code paths return a value.    并非所有代码路径都返回值。|
7031|     错误|     Binding element '{0}' implicitly has an '{1}' type.|
7032|     错误|     Property '{0}' implicitly has type 'any', because its set accessor lacks a parameter type annotation.|
7033|     错误|     Property '{0}' implicitly has type 'any', because its get accessor lacks a return type annotation.|
7034|     错误|     Variable '{0}' implicitly has type '{1}' in some locations where its type cannot be determined.|
8000|     错误|     You cannot rename this element.    无法重命名此元素。|
8001|     错误|     You cannot rename elements that are defined in the standard TypeScript library.    不能重命名标准 TypeScript 库中定义的元素。|
8002|     错误|     'import ... =' can only be used in a .ts file.    "import ... =" 只能在 .ts 文件中使用。|
8003|     错误|     'export=' can only be used in a .ts file.    "export=" 只能在 .ts 文件中使用。|
8004|     错误|     'type parameter declarations' can only be used in a .ts file.    "type parameter declarations" 只能在 .ts 文件中使用。|
8005|     错误|     'implements clauses' can only be used in a .ts file.    "implements clauses" 只能在 .ts 文件中使用。|
8006|     错误|     'interface declarations' can only be used in a .ts file.    "interface declarations" 只能在 .ts 文件中使用。|
8007|     错误|     'module declarations' can only be used in a .ts file.    "module declarations" 只能在 .ts 文件中使用。|
8008|     错误|     'type aliases' can only be used in a .ts file.    "type aliases" 只能在 .ts 文件中使用。|
8009|     错误|     '{0}' can only be used in a .ts file.    “{0}”只能在 .ts 文件中使用。|
8010|     错误|     'types' can only be used in a .ts file.    "types" 只能在 .ts 文件中使用。|
8011|     错误|     'type arguments' can only be used in a .ts file.    "type arguments" 只能在 .ts 文件中使用。|
8012|     错误|     'parameter modifiers' can only be used in a .ts file.    "parameter modifiers" 只能在 .ts 文件中使用。|
8015|     错误|     'enum declarations' can only be used in a .ts file.    "enum declarations" 只能在 .ts 文件中使用。|
8016|     错误|     'type assertion expressions' can only be used in a .ts file.    "type assertion expressions" 只能在 .ts 文件中使用。|
9002|     错误|     Only identifiers/qualified-names with optional type arguments are currently supported in a class 'extends' clauses.    类 "extends" 子句当前只支持具有可选类型参数的标识符/限定名称。|
9003|     错误|     'class' expressions are not currently supported.    当前不支持 "class" 表达式。|
9004|     错误|     Language service is disabled.|
17000|     错误|     JSX attributes must only be assigned a non-empty 'expression'.    只能为 JSX 属性分配非空“表达式”。|
17001|     错误|     JSX elements cannot have multiple attributes with the same name.    JSX 元素不能具有多个名称相同的特性。|
17002|     错误|     Expected corresponding JSX closing tag for '{0}'.    “{0}”预期的相应 JSX 结束标记。|
17003|     错误|     JSX attribute expected.    需要 JSX 属性。|
17004|     错误|     Cannot use JSX unless the '--jsx' flag is provided.    无法使用 JSX，除非提供了 "--jsx" 标志。|
17005|     错误|     A constructor cannot contain a 'super' call when its class extends 'null'    当构造函数的类扩展 "null" 时，它不能包含 "super" 调用。|
17006|     错误|     An unary expression with the '{0}' operator is not allowed in the left-hand side of an exponentiation expression. Consider enclosing the expression in parentheses.    乘方表达式的左侧不允许存在具有“{0}”运算符的一元表达式。请考虑用括号将表达式括起。|
17007|     错误|     A type assertion expression is not allowed in the left-hand side of an exponentiation expression. Consider enclosing the expression in parentheses.    乘方表达式的左侧不允许出现类型断言表达式。请考虑用括号将表达式括起。|
17008|     错误|     JSX element '{0}' has no corresponding closing tag.    JSX element '{0}' has no corresponding closing tag.|
17009|     错误|     'super' must be called before accessing 'this' in the constructor of a derived class.    'super' must be called before accessing 'this' in the constructor of a derived class.|
17010|     错误|     Unknown type acquisition option '{0}'.    Unknown typing option '{0}'.|
17011|     错误|     'super' must be called before accessing a property of 'super' in the constructor of a derived class.|
17012|     错误|     '{0}' is not a valid meta-property for keyword '{1}'. Did you mean '{0}'?    Too many JavaScript files in the project. Consider specifying the 'exclude' setting in project configuration to limit included source folders. The likely folder to exclude is '{0}'. To disable the project size limit, set the 'disableSizeLimit' compiler option to 'true'.|
17013|     错误|     Meta-property '{0}' is only allowed in the body of a function declaration, function expression, or constructor.|
18000|     错误|     Circularity detected while resolving configuration: {0}|
18001|     错误|     A path in an 'extends' option must be relative or rooted, but '{0}' is not.|
18002|     错误|     The 'files' list in config file '{0}' is empty.|
18003|     错误|     No inputs were found in config file '{0}'. Specified 'include' paths were '{1}' and 'exclude' paths were '{2}'.|
90001|     信息|     Add missing 'super()' call.|
90002|     信息|     Make 'super()' call the first statement in the constructor.|
90003|     信息|     Change 'extends' to 'implements'.|
90004|     信息|     Remove unused identifiers.|
90006|     信息|     Implement interface '{0}'.|
90007|     信息|     Implement inherited abstract class.|
90009|     错误|     Adding a tsconfig.json file will help organize projects that contain both TypeScript and JavaScript files. Learn more at <https://aka.ms/tsconfig>|
90010|     错误|     Type '{0}' is not assignable to type '{1}'. Two different types with this name exist, but they are unrelated.|
90013|     信息|     Import {0} from {1}|
90014|     信息|     Change {0} to {1}|
90015|     信息|     Add {0} to existing import declaration from {1}|
8017|     错误|     Octal literal types must use ES2015 syntax. Use the syntax '{0}'.|
8018|     错误|     Octal literals are not allowed in enums members initializer. Use the syntax '{0}'.|
