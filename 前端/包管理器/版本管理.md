# 版本管理

> 版本管理标准 [semver](https://semver.org/)

## package 文件

- node 项目中使用到的相关依赖和依赖的版本号

- 在 package.json 的依赖中，版本号使用的是semver 版本表示法，即“主版本.次版本.补丁版本”的格式，版本号的递增规则如下：

  - 主版本号，一些不兼容的 breaking change
  - 次版本号，能向下兼容，在不影响低版本的使用下可以新增和弃用一些 api，但要确保向下兼容
  - 补丁版本号，一些向下兼容的修正，一般都是对于一些缺陷的修复 当发布新版本的时候，可不能随心所欲地增加数字，一定要遵循上述的规则，这是作为一个合格的项目所必备的基本条件。 同时，npm 也设置了一些规则，用于在运行 np`m update 的时候，为 package.json 中的依赖更新到尽可能新的版本号，你一定不陌生
  - `～`: 只更新修订号，用于静默获取一些包中对于 bug 修复的最新版本
  - `^`: 只执行不更新最左边非零数字版本号的更新。例如 ^0.1.0 ，可以更新到 0.1.1 0.1.2 等，但不会更新到 0.2.0 或更高版本；而 1.0.0 可以更新到 1.0.1 或 1.1.0 等，但不会更新到 2.0.0 或更高版本
  - `>`: 只接受高于指定版本的任何版本
  - `≥`: 只接受高于或等于指定版本的任何版本
  - `<`: 只接受低于指定版本的任何版本
  - `≤`: 只接受低于或等于指定版本的任何版本
  - `=`: 接受确切版本
  - `-`: 接受一定范围的版本，如：`2.1.0-2.6.2`
  - `||`: 组合集合，如： `< 2.1 || > 2.6`
  - `latest`: 使用可用的最新版本
  - 无符号，等同于 `=`

## package lock 文件

- 在 npm 5 版本中，引入了 package-lock.json 文件
- 其它的包管理工具也有其对应的 lock 文件，如 yarn 的 yarn.lock 、pnpm 的 pnpm-lock.yaml
- package-lock.json 文件相比 package.json 文件
  - 不仅可以跟踪项目中使用到的 npm 包
  - 还能跟踪每个 npm 包的确切版本
  - 以确保产品可以拥有完整且相同的 node_modules 树，产品的表现形式一致
- 正如上述关于 package.json 依赖工作的描述，package.json 一直都存在着一个比较尴尬的问题，即在运行 npm update 或者 npm install 的时候，会尽可能地安装最新的依赖，如果虽然补丁版本和次版本不应该引入重大的更改，但并不是所有的开源项目的作者都是遵守 semver 规则（我相信有些人可能都还不知道这东东），免不了的，还是有可能会产生 bug。 那如果在服务器的 ci 服务器，每次都是先 npm install 安装依赖再执行打包构建的时候，不就有可能会产生问题了吗？ 这里就不得不先提一下 npm ci 这个命令了，npm ci 跟 npm install 不同。看到 ci，也应该能想到持续集成中的这个 ci。没错啦，这个就是专门用于 CI/CD 中的安装依赖操作。
 npm ci 相比 npm install 命令，有几个特点： npm 版本要 ≥ v5.7.1

- 不会更改 package.json 、package-lock.json 文件
- 执行的之前如果存在 node_modules ，会先将之删除
- 优先依赖于 package-lock.json 或 npm-shrinkwrap.json 文件安装依赖
- 如果在以上两个文件中的依赖在 package.json 中找不到，就抛错退出执行 这些特性确保了相同的 lock 文件能拥有相同的依赖环境，避免在构建的时候出现与开发时环境不一致的情况。
